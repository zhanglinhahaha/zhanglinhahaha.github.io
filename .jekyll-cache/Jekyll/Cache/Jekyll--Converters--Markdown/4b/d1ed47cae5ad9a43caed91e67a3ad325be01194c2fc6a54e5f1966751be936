I"â<h3 id="ç»„åˆæ¨¡å¼">ç»„åˆæ¨¡å¼</h3>
<p>Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.
(å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤ºâ€œéƒ¨åˆ†-æ•´ä½“â€çš„å±‚æ¬¡ç»“æ„,ä½¿å¾—ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚)</p>
<h3 id="é€šç”¨ç±»å›¾">é€šç”¨ç±»å›¾</h3>
<p>æŠ½è±¡æ„ä»¶è§’è‰²ç±»
å®šä¹‰å‚åŠ ç»„åˆå¯¹è±¡çš„å…¬æœ‰æ–¹æ³•å’Œå±æ€§ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸‹é»˜è®¤çš„è¡Œä¸ºæˆ–å±æ€§
å¶å­æ„ä»¶ç±»
å¶å­å¯¹è±¡ï¼Œå…¶ä¸‹å†ä¹Ÿæ²¡æœ‰å…¶ä»–çš„åˆ†æ”¯ï¼Œéå†çš„æœ€å°å•ä½ï¼Œç»§æ‰¿æŠ½è±¡æ„ä»¶è§’è‰²ç±»
æ ‘ææ„ä»¶ç±»
ç»„åˆæ ‘æèŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹å½¢æˆä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œç»§æ‰¿æŠ½è±¡æ„ä»¶è§’è‰²ç±»ï¼Œå¹¶ä¸”ä¸ä¹‹æ˜¯æ•´ä½“ä¸éƒ¨åˆ†å…³ç³»</p>
<h3 id="é€šç”¨æºç ">é€šç”¨æºç </h3>
<p>//æŠ½è±¡æ„ä»¶ç±»
class Component {
public:
    virtual void doSomething() {
        //ä¸šåŠ¡é€»è¾‘
    }
};
//æ ‘ææ„ä»¶ç±»ï¼Œç»„åˆæ¨¡å¼çš„é‡ç‚¹
class Composite : public Component {
private:
    //æ„ä»¶å®¹å™¨
    vector&lt;Component<em>&gt; vc;
public:
    //å¢åŠ ä¸€ä¸ªå¶å­æ„ä»¶æˆ–æ ‘ææ„ä»¶
    void add(Component *c) { vc.push_back(c);}
    //åˆ é™¤ä¸€ä¸ªå¶å­æ„ä»¶æˆ–æ ‘ææ„ä»¶
    void remove(Component *c) {
        auto iter = vc.find(vc.begin(), vc.end(), c);
        vc.erase(c);
    }
    //è·å¾—åˆ†æ”¯ä¸‹çš„æ‰€æœ‰å¶å­æ„ä»¶å’Œæ ‘ææ„ä»¶
    vector&lt;Component</em>&gt; getChildren() {
        return vc;
    }
};
//å¶å­æ„ä»¶ç±»
class Leaf : public Component {
public:
    void doSomething() {
    }
};</p>
<h3 id="ä¼˜ç‚¹">ä¼˜ç‚¹</h3>
<p>é«˜å±‚æ¨¡å—è°ƒç”¨ç®€å•
èŠ‚ç‚¹è‡ªç”±å¢åŠ ï¼Œç¬¦åˆå¼€é—­åŸåˆ™</p>
<h3 id="ç¼ºç‚¹">ç¼ºç‚¹</h3>
<p>è¿èƒŒä¾èµ–å€’ç½®åŸåˆ™ï¼Œæ²¡æœ‰é¢å‘æ¥å£ç¼–ç¨‹</p>
<h3 id="ä½¿ç”¨åœºæ™¯">ä½¿ç”¨åœºæ™¯</h3>
<p>ç»´æŠ¤å’Œå±•ç¤ºéƒ¨åˆ†-æ•´ä½“çš„åœºæ™¯ï¼Œå¦‚æ ‘æ€§èœå•ã€æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ç®¡ç†
ä»ä¸€ä¸ªæ•´ä½“ä¸­èƒ½å¤Ÿç‹¬ç«‹å‡ºéƒ¨åˆ†æ¨¡å—æˆ–åŠŸèƒ½çš„åœºæ™¯</p>
<h3 id="æ‰©å±•">æ‰©å±•</h3>
<p>ä¸å…³ç³»æ•°æ®åº“ç»“åˆä½¿ç”¨ï¼Œèƒ½å¤Ÿè½»æ¾çš„å®ç°æ ‘çš„ç»„è£…
é€æ˜çš„ç»„åˆæ¨¡å¼ï¼ŒæŠŠæ ‘ææ„ä»¶ä¸­çš„æ–¹æ³•æ”¾åˆ°æŠ½è±¡ç±»ä¸­å®ç°ï¼Œéµå¾ªä¾èµ–å€’ç½®åŸåˆ™
ç»„åˆæ¨¡å¼çš„éå†ï¼Œå¢åŠ è®¾ç½®çˆ¶èŠ‚ç‚¹çš„æ–¹æ³•ï¼Œå®ç°ä»åº•å¾€ä¸Šçš„éå†</p>
<h3 id="ç¤ºä¾‹ä»£ç ">ç¤ºä¾‹ä»£ç </h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Corp {
public:
    Corp(const string&amp; n, const string&amp; p, int s): name(n), position(p), salary(s) { }
    string getinfo() {
        string info = name + ", "+ position + ", ";
        info += to_string(salary);
        return info;
    }
private:
    string name;
    string position;
    int salary;
};

class Leaf : public Corp {
public:
    Leaf(const string&amp; n, const string&amp; p, int s): Corp(n, p, s) { }
};

class Branch : public Corp {
public:
    Branch(const string&amp; n, const string&amp; p, int s): Corp(n, p, s){ }
    void addSubordinate(Corp *ic) {
        vIc.push_back(ic);
    }
    vector&lt;Corp*&gt; getSubordinate() {
        return vIc;
    }
private:
    vector&lt;Corp*&gt; vIc;
};

int main() {
    Branch ceo("zzzl", "ceo", 10000);
    Branch dev("lzzl", "dev", 8000);
    Branch sal("llzl", "sal", 8000);
    Leaf a("zzl1", "dev1", 5000);
    Leaf b("zzl2", "dev2", 5000);
    Leaf c("lzl1", "sal1", 5000);
    Leaf d("lzl2", "sal2", 5000);
    Leaf e("lll", "ass", 5000);
    ceo.addSubordinate(&amp;dev);
    ceo.addSubordinate(&amp;sal);
    ceo.addSubordinate(&amp;e);
    dev.addSubordinate(&amp;a);
    dev.addSubordinate(&amp;b);
    sal.addSubordinate(&amp;c);
    sal.addSubordinate(&amp;d);
    cout &lt;&lt; ceo.getinfo() &lt;&lt; endl;
    vector&lt;Branch&gt; vb;
    vb.push_back(ceo);
    vb.push_back(dev);
    vb.push_back(sal);
    for(i : vb) {
        vector&lt;Corp*&gt; v = i.getSubordinate();
        for(j : v)
            cout &lt;&lt; j-&gt;getinfo() &lt;&lt; endl;
    }
    return 0;
}
</code></pre></div></div>

:ET