I"¸<h3 id="è§‚å¯Ÿè€…æ¨¡å¼">è§‚å¯Ÿè€…æ¨¡å¼</h3>
<p>ä¹Ÿå«åšå‘å¸ƒè®¢é˜…æ¨¡å¼(Publish/subscribe)
Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.
(å®šä¹‰å¯¹è±¡é—´ä¸€ç§ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»,ä½¿å¾—æ¯å½“ä¸€ä¸ªå¯¹è±¡æ”¹å˜çŠ¶æ€,åˆ™æ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½ä¼šå¾—åˆ°é€šçŸ¥å¹¶è¢«è‡ªåŠ¨æ›´æ–°ã€‚)</p>
<h3 id="é€šç”¨ç±»å›¾">é€šç”¨ç±»å›¾</h3>
<p>è¢«è§‚å¯Ÿè€…æŠ½è±¡ç±»
å®šä¹‰è¢«è§‚å¯Ÿè€…å¿…é¡»å®ç°çš„èŒè´£ï¼Œèƒ½å¤ŸåŠ¨æ€çš„å¢åŠ ã€å–æ¶ˆè§‚å¯Ÿè€…ï¼Œå®Œæˆè¢«è§‚å¯Ÿè€…å¿…é¡»å®ç°çš„èŒè´£ï¼šç®¡ç†è§‚å¯Ÿè€…å¹¶é€šçŸ¥è§‚å¯Ÿè€…
è¢«è§‚å¯Ÿè€…å…·ä½“ç±»
ç»§æ‰¿å…¶æŠ½è±¡ç±»ï¼Œå®šä¹‰è‡ªå·±çš„ä¸šåŠ¡é€»è¾‘ï¼Œå®šä¹‰å¯¹å“ªäº›äº‹ä»¶è¿›è¡Œé€šçŸ¥
è§‚å¯Ÿè€…æŠ½è±¡ç±»
è§‚å¯Ÿè€…æ¥æ”¶åˆ°æ¶ˆæ¯åï¼Œå¯¹ä¿¡æ¯è¿›è¡Œå¤„ç†
è§‚å¯Ÿè€…å…·ä½“ç±»
ç»§æ‰¿å…¶æŠ½è±¡ç±»ï¼Œæ¯ä¸ªè§‚å¯Ÿè€…æ”¶åˆ°ä¿¡æ¯åçš„å¤„ç†ä¸åŒï¼Œå®ç°å„è‡ªçš„é€»è¾‘</p>
<h3 id="é€šç”¨æºç ">é€šç”¨æºç </h3>
<p>//è¢«è§‚å¯Ÿè€…æŠ½è±¡ç±»
class Subject {
public:
    //å¢åŠ è§‚å¯Ÿè€…
    void addObserver(Observer <em>ob) {
        sob.insert(ob);
    }
    //åˆ é™¤è§‚å¯Ÿè€…
    void deleteObserver(Observer *ob) {
        sob.erase(ob);
    }
    //é€šçŸ¥è§‚å¯Ÿè€…
    void notifyObservers() {
        for(auto ob : sob) ob-&gt;updated();
    }
private:
    //å®šä¹‰è§‚å¯Ÿæ•°ç»„
    set&lt;Observer</em>&gt; sob;
};
//è¢«è§‚å¯Ÿè€…å…·ä½“ç±»
class ConcreteSubject : public Subject {
public:
    void doSomething() {
        //do something
        Subject::notifyObservers();
    }
};
//è§‚å¯Ÿè€…æŠ½è±¡ç±»
class Observer {
public:
    //æ›´æ–°æ–¹æ³•
    virtual void updated() = 0;
};
//è§‚å¯Ÿè€…å…·ä½“ç±»
class ConcreteObserver : public Observer {
public:
    void updated() override {
        //æ”¶åˆ°æ¶ˆæ¯ï¼Œé€»è¾‘å¤„ç†
    }
};</p>
<h3 id="ä¼˜ç‚¹">ä¼˜ç‚¹</h3>
<p>è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…ä¹‹é—´æ˜¯æŠ½è±¡è€¦åˆï¼Œè§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…éƒ½éå¸¸å®¹æ˜“æ‰©å±•
å»ºç«‹ä¸€å¥—è§¦å‘æœºåˆ¶ï¼Œä¸€ä¸ªäº‹ç‰©çš„æ”¹å˜å¼•èµ·å…¶ä»–äº‹ç‰©çš„å˜åŒ–</p>
<h3 id="ç¼ºç‚¹">ç¼ºç‚¹</h3>
<p>éœ€è¦è€ƒè™‘å¼€å‘æ•ˆç‡å’Œè¿è¡Œæ•ˆç‡</p>
<h3 id="ä½¿ç”¨åœºæ™¯">ä½¿ç”¨åœºæ™¯</h3>
<p>å…³è”è¡Œä¸ºåœºæ™¯
äº‹ä»¶å¤šçº§è§¦å‘åœºæ™¯
è·¨ç³»ç»Ÿçš„æ¶ˆæ¯äº¤æ¢åœºæ™¯</p>
<h3 id="æ³¨æ„äº‹é¡¹">æ³¨æ„äº‹é¡¹</h3>
<p>å¹¿æ’­é“¾çš„é—®é¢˜
å½“ä¸€ä¸ªå¯¹è±¡æ—¢æ˜¯è§‚å¯Ÿè€…åˆæ˜¯è¢«è§‚å¯Ÿè€…ï¼Œä¼šå¯¼è‡´é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œå¯ç»´æŠ¤æ€§å˜å·®
å¼‚æ­¥å¤„ç†é—®é¢˜
å½“è§‚å¯Ÿè€…éå¸¸å¤šçš„æ—¶å€™ï¼Œå¼‚æ­¥å¤„ç†ï¼Œéœ€è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨å’Œé˜Ÿåˆ—çš„é—®é¢˜</p>
<h3 id="ç¤ºä¾‹ä»£ç ">ç¤ºä¾‹ä»£ç </h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include &lt;set&gt;

using namespace std;

class IHanFeiZi {
public:
    virtual void haveBreakfast() = 0;
    virtual void haveFun() = 0;
};

/*
class HanFeiZi : public IHanFeiZi {
public:
    void haveBreakfast() override {
        cout &lt;&lt; "HanFeiZi: have breakfast..." &lt;&lt; endl;
        isHavingBreakfast = true;
    }
    void haveFun() override {
        cout &lt;&lt; "HanFeiZi: have fun..." &lt;&lt; endl;
        isHavingFun = true;
    }
    void setHavingBreakfast(bool b) {isHavingBreakfast = b;}
    bool getHavingBreakfast() {return isHavingBreakfast;}
    void setHavingFun(bool b) {isHavingFun = b;}
    bool getHavingFun() {return isHavingFun;}
private:
    bool isHavingBreakfast = false;
    bool isHavingFun = false;
};

class ILiSi {
public:
    virtual void update(string) = 0;
};

class LiSi : public ILiSi {
public:
    void update(string s) override {
        cout &lt;&lt; "LiSi: report:" &lt;&lt; endl;
        reportToQinShiHuang(s);
        cout &lt;&lt; "LiSi: over" &lt;&lt; endl;
    }
private:
    void reportToQinShiHuang(string s) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
};

class Spy{
public:
    Spy(HanFeiZi &amp;h, LiSi &amp;l, string s):han(h), li(l), type(s) {
        thread t(bind(&amp;Spy::run, this));
        t.detach();
    }
    void run() {
        while(r) {
            if(type == "breakfast") {
                if(han.getHavingBreakfast()) {
                    li.update("have breakfast");
                    han.setHavingBreakfast(false);
                }
            }else {
                if(han.getHavingFun()) {
                    li.update("have fun");
                    han.setHavingFun(false);
                }
            }
        }
    }
    void setRun(bool b) {
        r = b;
    }
private:
    bool r = true;
    HanFeiZi&amp; han;
    LiSi&amp; li;
    string type;
};
*/
//modify
class Observer {
public:
    virtual void update(string) = 0;
};

class Observable {
public:
    virtual void addObserver(Observer*) = 0;
    virtual void deleteObserver(Observer*) = 0;
    virtual void notifyObservers(string) = 0;
};

class HanFeiZi_t : public Observable, public IHanFeiZi {
public:
    void addObserver(Observer* ob) override {
        sob.insert(ob);
    }
    void deleteObserver(Observer* ob) override {
        sob.erase(ob);
    }
    void notifyObservers(string s) override {
        for(auto ob : sob) ob-&gt;update(s);
    }
    void haveBreakfast() override {
        cout &lt;&lt; "HanFeiZi: have breakfast..." &lt;&lt; endl;
        notifyObservers("have breakfast");
    }
    void haveFun() override {
        cout &lt;&lt; "HanFeiZi: have fun..." &lt;&lt; endl;
        notifyObservers("have fun");
    }
private:
    set&lt;Observer*&gt; sob;
};

class LiSi : public Observer {
public:
    void update(string s) override {
        cout &lt;&lt; "LiSi: report:" &lt;&lt; endl;
        reportToQinShiHuang(s);
        cout &lt;&lt; "LiSi: over" &lt;&lt; endl;
    }
private:
    void reportToQinShiHuang(string s) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
};
class WangSi : public Observer {
public:
    void update(string s) override {
        cout &lt;&lt; "WangSi: report:" &lt;&lt; endl;
        reportToQinShiHuang(s);
        cout &lt;&lt; "WangSi: over" &lt;&lt; endl;
    }
private:
    void reportToQinShiHuang(string s) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
};
class LiuSi : public Observer {
public:
    void update(string s) override {
        cout &lt;&lt; "LiuSi: report:" &lt;&lt; endl;
        reportToQinShiHuang(s);
        cout &lt;&lt; "LiuSi: over" &lt;&lt; endl;
    }
private:
    void reportToQinShiHuang(string s) {
        cout &lt;&lt; s &lt;&lt; endl;
    }
};

int main() {
    /*
    LiSi l;
    HanFeiZi h;
    string s1 = "fun";
    string s2 = "breakfast";
    Spy fun(h, l, s1);
    Spy breakfast(h, l, s2);
    cout &lt;&lt; "fun begin" &lt;&lt;endl;
    h.haveFun();
    sleep(1);
    cout &lt;&lt; "breakfast begin" &lt;&lt; endl;
    h.haveBreakfast();
    sleep(1);
    fun.setRun(0);
    breakfast.setRun(0);
    cout &lt;&lt; "spy end" &lt;&lt; endl;
    */
    LiSi li;
    LiuSi liu;
    WangSi wang;
    HanFeiZi_t ht;
    ht.addObserver(&amp;li);
    ht.addObserver(&amp;liu);
    ht.addObserver(&amp;wang);
    ht.haveBreakfast();
    ht.deleteObserver(&amp;wang);
    ht.haveFun();
    return 0;
}
</code></pre></div></div>

:ET